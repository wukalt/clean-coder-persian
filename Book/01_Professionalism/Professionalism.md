 <div align="center">

![Conventions-UsedThis-Book](../../assets/images/01/1.png)
</div>

# حرفه‌ای‌گری

<div dir="rtl">
اوه، بخند کِرتین، رفیق قدیمی. این یک شوخی بزرگ است که خدا، یا سرنوشت، یا طبیعت—هر کدام را که ترجیح می‌دهی—با ما کرده. اما هر کس یا هر چه این شوخی را ترتیب داده، قطعاً حس شوخ‌طبعی داشته! ها!

---

پس، می‌خواهی یک `professional software developer` (توسعه‌دهندهٔ نرم‌افزار حرفه‌ای) باشی، درست است؟
می‌خواهی سرت را بالا بگیری و با صدای بلند به دنیا اعلام کنی: «من یک حرفه‌ای هستم!»
می‌خواهی مردم با احترام به تو نگاه کنند و با ملاحظه با تو رفتار کنند.
می‌خواهی مادرها به تو اشاره کنند و به بچه‌هایشان بگویند مثل تو باشند.
همهٔ این‌ها را می‌خواهی. درست است؟

## مراقب باش چه چیزی را طلب می‌کنی.

`Professionalism` (حرفه‌ای‌گری) واژه‌ای سنگین و پرمعناست.
قطعاً نشانه‌ای از افتخار و غرور است، اما هم‌زمان نشانه‌ای از مسئولیت‌پذیری و پاسخ‌گویی هم هست.
این دو همیشه همراه هم‌اند.
نمی‌توانی به چیزی افتخار کنی که حاضر نیستی مسئولیتش را بپذیری.

غیرحرفه‌ای بودن خیلی راحت‌تر است.
غیرحرفه‌ای‌ها لازم نیست مسئول کارشان باشند — این مسئولیت را به کارفرمایشان می‌سپارند.
اگر یک غیرحرفه‌ای اشتباهی مرتکب شود، کارفرماست که خرابی را جمع می‌کند.
اما وقتی یک حرفه‌ای اشتباه می‌کند، خودش خرابی را جمع می‌کند.

اگر اجازه بدهی یک `bug` (باگ / خطا) از یک ماژول عبور کند و این اشتباه ۱۰٬۰۰۰ دلار به شرکتت ضرر بزند، چه می‌شود؟
یک غیرحرفه‌ای شانه بالا می‌اندازد، می‌گوید «پیش میاد»، و می‌رود سراغ نوشتن ماژول بعدی.
اما یک حرفه‌ای یک چک ۱۰٬۰۰۰ دلاری برای شرکت می‌نویسد!¹

بله، وقتی پای پول خودت وسط باشد، حسش فرق می‌کند، نه؟
اما این همان حسی است که یک حرفه‌ای همیشه دارد.
در واقع، همین حس، جوهرهٔ حرفه‌ای‌گری است.
چون حرفه‌ای‌گری یعنی پذیرفتن مسئولیت.

## پذیرفتن مسئولیت

مقدمه را خواندی، درست است؟
اگر نه، برگرد و همین حالا بخوانش؛ چون زمینهٔ همهٔ آنچه در ادامهٔ این کتاب می‌آید را می‌سازد.

من مفهوم مسئولیت‌پذیری را با تحمل پیامدهای عدم پذیرش آن یاد گرفتم.
در سال ۱۹۷۹ برای شرکتی به نام `Teradyne` کار می‌کردم.
من `«responsible engineer` (مهندس مسئول)» نرم‌افزاری بودم که یک سیستم مبتنی بر مینی‌کامپیوتر و میکروکامپیوتر را کنترل می‌کرد؛ سیستمی که کیفیت خطوط تلفن را اندازه‌گیری می‌کرد.
مینی‌کامپیوتر مرکزی از طریق خطوط تلفن اختصاصی یا دایل‌آپ با سرعت ۳۰۰ `baud` به ده‌ها میکروکامپیوتر ماهواره‌ای متصل بود که سخت‌افزار اندازه‌گیری را کنترل می‌کردند.
تمام کدها با `assembler` (اسمبلر) نوشته شده بودند.

مشتریان ما مدیران خدمات شرکت‌های بزرگ تلفن بودند.
هر کدام مسئول بیش از ۱۰۰٬۰۰۰ خط تلفن بودند.
سیستم من به این مدیران کمک می‌کرد تا نقص‌ها و مشکلات خطوط تلفن را قبل از اینکه مشتریان متوجه شوند شناسایی و برطرف کنند.
این کار نرخ شکایت مشتریان را کاهش می‌داد؛ نرخی که کمیسیون‌های خدمات عمومی برای تنظیم تعرفه‌ها از آن استفاده می‌کردند.
به‌طور خلاصه، این سیستم‌ها فوق‌العاده حیاتی بودند.

هر شب این سیستم‌ها یک `«nightly routine (روال شبانه)»` اجرا می‌کردند.
در این روال، مینی‌کامپیوتر مرکزی به هر میکروکامپیوتر ماهواره‌ای دستور می‌داد تا تمام خطوط تلفن تحت کنترلش را تست کند.
هر صبح، کامپیوتر مرکزی فهرست خطوط معیوب و ویژگی‌های خرابی آن‌ها را جمع‌آوری می‌کرد.
مدیران خدمات از این گزارش برای برنامه‌ریزی اعزام تعمیرکاران استفاده می‌کردند، پیش از آنکه مشتریان شکایت کنند.

یک‌بار نسخهٔ جدیدی را برای چند ده مشتری ارسال کردم.
کلمهٔ «ارسال» دقیقاً درست است.
من نرم‌افزار را روی نوار مغناطیسی نوشتم و آن نوارها را برای مشتریان فرستادم.
مشتریان نوارها را بارگذاری کردند و سیستم‌ها را `reboot` کردند.

نسخهٔ جدید چند نقص جزئی را رفع می‌کرد و یک قابلیت جدید اضافه می‌کرد که مشتریان مدت‌ها خواستارش بودند.
به آن‌ها قول داده بودیم این قابلیت را تا تاریخ مشخصی ارائه دهیم.
من به‌زحمت توانستم نوارها را طوری ارسال کنم که دقیقاً در همان تاریخ وعده‌داده‌شده برسند.

دو روز بعد، از مدیر خدمات میدانی‌مان، Tom، تماس گرفتم.
او گفت چند مشتری شکایت کرده‌اند که روال شبانه کامل اجرا نشده و هیچ گزارشی دریافت نکرده‌اند.
دلم فرو ریخت، چون برای اینکه نرم‌افزار را به‌موقع ارسال کنم، تست این روال را انجام نداده بودم.
بیشتر قابلیت‌های دیگر سیستم را تست کرده بودم، اما تست این روال ساعت‌ها طول می‌کشید و من باید نرم‌افزار را ارسال می‌کردم.
هیچ‌کدام از رفع باگ‌ها مربوط به کد روال نبود، پس خیال کردم مشکلی نیست.

از دست دادن گزارش شبانه موضوع کوچکی نبود.
یعنی تعمیرکارها کار کمتری داشتند و بعداً بیش‌ازحد برنامه‌ریزی می‌شدند.
یعنی ممکن بود بعضی مشتریان متوجه خرابی شوند و شکایت کنند.
از دست دادن داده‌های یک شب کافی بود تا یک مدیر خدمات با Tom تماس بگیرد و حسابی سرش فریاد بزند.

سیستم آزمایشگاهی را روشن کردم، نرم‌افزار جدید را بارگذاری کردم و روال شبانه را اجرا کردم.
چند ساعت طول کشید و بعد… متوقف شد.
روال شکست خورد.
اگر قبل از ارسال این تست را انجام داده بودم، داده‌ای از دست نمی‌رفت و مدیران خدمات الآن سر Tom داد نمی‌زدند.

به Tom زنگ زدم و گفتم می‌توانم مشکل را بازتولید کنم.
او گفت بیشتر مشتریان دیگر هم با همین شکایت تماس گرفته‌اند.
بعد از من پرسید چه زمانی می‌توانم درستش کنم.
گفتم نمی‌دانم، اما دارم رویش کار می‌کنم.
در همین حین گفتم مشتریان باید به نسخهٔ قدیمی برگردند.
او عصبانی شد و گفت این ضربهٔ دومی به مشتری‌هاست: هم یک شب داده از دست داده‌اند و هم نمی‌توانند از قابلیت جدید استفاده کنند.

باگ پیدا کردنش سخت بود و هر بار تست چند ساعت طول می‌کشید.
اولین اصلاح جواب نداد.
دومی هم همین‌طور.
چندین تلاش و چندین روز طول کشید تا بفهمم دقیقاً چه اشتباهی رخ داده.
در تمام این مدت، Tom هر چند ساعت یک‌بار تماس می‌گرفت و می‌پرسید کی درست می‌شود.
او مطمئن می‌شد من از داد و فریادهایی که از مدیران خدمات می‌شنود و از شرمندگی‌ای که بابت گفتن «نوارهای قدیمی را برگردانید» دارد، کاملاً باخبرم.

در نهایت نقص را پیدا کردم، نوارهای جدید را ارسال کردم و همه‌چیز به حالت عادی برگشت.
Tom که رئیس من نبود، آرام شد و ماجرا تمام شد.
رئیس من بعد از پایان ماجرا آمد و گفت: «شرط می‌بندم دیگه این کارو نمی‌کنی.»
من هم موافقت کردم.

بعد که فکر کردم، فهمیدم ارسال نرم‌افزار بدون تست روال، غیرمسئولانه بوده.
دلیل اینکه تست را انجام ندادم این بود که بتوانم بگویم «به‌موقع ارسال کردم».
موضوع حفظ آبروی خودم بود.
نه نگران مشتری بودم، نه نگران کارفرما.
فقط نگران اعتبار شخصی خودم بودم.
باید زودتر مسئولیت را می‌پذیرفتم و به Tom می‌گفتم تست‌ها کامل نشده و آمادهٔ ارسال نیستم.
این کار سخت بود و Tom ناراحت می‌شد، اما هیچ داده‌ای از دست نمی‌رفت و هیچ مدیری تماس نمی‌گرفت.

## اول، آسیب نزن

پس چطور مسئولیت‌پذیر باشیم؟
اصولی وجود دارد.
الهام گرفتن از `Hippocratic Oath` (`سوگند بقراط`) شاید متکبرانه به نظر برسد، اما منبع بهتری سراغ دارید؟
آیا منطقی نیست که اولین مسئولیت و اولین هدف یک حرفه‌ایِ در حال رشد این باشد که از توانایی‌هایش برای خیر استفاده کند؟

یک توسعه‌دهندهٔ نرم‌افزار چه آسیبی می‌تواند بزند؟
از دید صرفاً نرم‌افزاری، می‌تواند به عملکرد و ساختار نرم‌افزار آسیب بزند.
بررسی می‌کنیم که چطور از این آسیب‌ها جلوگیری کنیم.

### آسیب نرساندن به function (عملکرد)

واضح است که ما می‌خواهیم نرم‌افزارمان کار کند.
در واقع، بیشتر ما امروز برنامه‌نویس هستیم چون یک‌بار موفق شدیم چیزی را به کار بیندازیم و حالا دوباره همان حس را می‌خواهیم.
اما ما تنها کسانی نیستیم که می‌خواهیم نرم‌افزار کار کند.
مشتریان و کارفرمایان ما هم می‌خواهند نرم‌افزار کار کند.
در حقیقت، آن‌ها به ما پول می‌دهند تا نرم‌افزاری بسازیم که دقیقاً همان‌طور که می‌خواهند کار کند.

ما زمانی به عملکرد نرم‌افزار آسیب می‌زنیم که `bug` (باگ) ایجاد می‌کنیم.
بنابراین، برای حرفه‌ای بودن، نباید باگ ایجاد کنیم.

«اما صبر کن!» صدایت را می‌شنوم که می‌گویی:
«این منطقی نیست. نرم‌افزار آن‌قدر پیچیده است که نمی‌شود بدون باگ ساختش.»

کاملاً درست می‌گویی.
نرم‌افزار آن‌قدر پیچیده است که نمی‌توان بدون باگ ساختش.
اما متأسفانه این موضوع تو را از مسئولیت مبرا نمی‌کند.
بدن انسان آن‌قدر پیچیده است که نمی‌توان آن را کاملاً درک کرد، اما پزشکان باز هم سوگند می‌خورند که آسیب نرسانند.
اگر آن‌ها نمی‌توانند خودشان را با این بهانه از زیر بار مسئولیت درببرند، ما چطور می‌توانیم؟

«یعنی داری می‌گویی باید کامل باشیم؟»

نه.
دارم می‌گویم باید مسئول نقص‌هایت باشی.
اینکه باگ‌ها قطعاً در کدت ظاهر می‌شوند، به این معنا نیست که مسئولشان نیستی.
اینکه نوشتن نرم‌افزار بی‌نقص عملاً غیرممکن است، به این معنا نیست که نسبت به نقص‌ها بی‌مسئولیتی.

سرنوشت یک حرفه‌ای این است که بابت خطاها پاسخ‌گو باشد، حتی وقتی وقوع خطا تقریباً قطعی است.
پس اولین چیزی که باید تمرین کنی عذرخواهی کردن است.
عذرخواهی لازم است، اما کافی نیست.
نمی‌توانی مدام همان اشتباهات را تکرار کنی.
هرچه در حرفه‌ات بالغ‌تر می‌شوی، نرخ خطایت باید به‌سرعت به سمت asymptote of zero (مجانب صفر) کاهش پیدا کند.
هرگز به صفر نمی‌رسد، اما مسئولیت توست که تا حد ممکن به آن نزدیک شوی.

### وقتی QA (Quality Assurance / تضمین کیفیت) نباید چیزی پیدا کند

بنابراین، وقتی نرم‌افزارت را منتشر می‌کنی، باید انتظار داشته باشی که QA هیچ مشکلی پیدا نکند.
ارسال عمدی کدی که می‌دانی معیوب است به QA، نهایت غیرحرفه‌ای‌گری است.
و چه کدی را می‌دانی معیوب است؟
هر کدی که از درست‌بودنش مطمئن نیستی!

بعضی‌ها از QA به‌عنوان شکارچی باگ استفاده می‌کنند.
کدی را که به‌طور کامل بررسی نکرده‌اند تحویل QA می‌دهند.
به QA متکی هستند تا باگ‌ها را پیدا کند و به توسعه‌دهنده گزارش دهد.
حتی بعضی شرکت‌ها QA را بر اساس تعداد باگ‌هایی که پیدا می‌کند پاداش می‌دهند.
هرچه باگ بیشتر، پاداش بیشتر.

مهم نیست که این رفتار به‌شدت پرهزینه است و به شرکت و نرم‌افزار آسیب می‌زند.
مهم نیست که این کار زمان‌بندی‌ها را نابود می‌کند و اعتماد سازمان به تیم توسعه را از بین می‌برد.
مهم نیست که این رفتار تنبلانه و غیرمسئولانه است.
ارسال کدی که مطمئن نیستی کار می‌کند به QA، غیرحرفه‌ای است.
این کار قانون «آسیب نرسان» را نقض می‌کند.

آیا QA باگ پیدا می‌کند؟
احتمالاً بله.
پس آمادهٔ عذرخواهی باش — و بعد بفهم چرا آن باگ‌ها از دیدت فرار کرده‌اند و کاری کن که دیگر تکرار نشوند.

هر بار که QA — یا بدتر از آن، یک کاربر — مشکلی پیدا می‌کند، باید متعجب، شرمنده، و مصمم شوی که جلوی تکرارش را بگیری.

## باید بدانی که کار می‌کند

چطور می‌توانی بدانی کدت کار می‌کند؟

ساده است.
- تستش کن.
- دوباره تستش کن.
- از بالا تست کن.
- از پایین تست کن.
- هفت‌جور تستش کن!

شاید نگران باشی که این‌همه تست وقت زیادی بگیرد.
بالاخره ددلاین و برنامه داری.
اگر تمام وقتت را صرف تست کنی، کی کد می‌نویسی؟
نکتهٔ خوبی است!
پس تست‌هایت را خودکار کن.

`unit test` (تست واحد) بنویس که بتوانی در یک لحظه اجراشان کنی و تا جایی که می‌توانی آن‌ها را اجرا کن.

چه مقدار از کد باید با تست‌های خودکار پوشش داده شود؟
واقعاً لازم است جواب بدهم؟
همه‌اش! همه.ٔ کد.

آیا دارم پیشنهاد 100% `test coverage` (پوشش تست صددرصدی) می‌دهم؟
نه، پیشنهاد نمی‌دهم.
مطالبه می‌کنم.

تک‌تک خطوط کدی که می‌نویسی باید تست شوند.
نقطه.

غیرواقعی نیست؟
نه.
تو فقط کدی می‌نویسی که انتظار داری اجرا شود.
اگر انتظار داری اجرا شود، باید بدانی که کار می‌کند.
و تنها راه دانستن این موضوع، تست کردن است.

من مشارکت‌کننده و کامیت‌کنندهٔ اصلی یک پروژهٔ متن‌باز به نام `FitNesse` هستم.
در زمان نوشتن این متن، `FitNesse` حدود `60ksloc` (۶۰ هزار خط کد) دارد.
۲۶ هزار خط از این‌ها در بیش از ۲۰۰۰ unit test نوشته شده‌اند.
ابزار `Emma` (ابزار اندازه‌گیری پوشش تست) گزارش می‌دهد که پوشش این تست‌ها حدود ۹۰٪ است.

چرا پوشش بالاتر نیست؟
چون `Emma` نمی‌تواند همهٔ خطوطی را که واقعاً اجرا می‌شوند ببیند!
من معتقدم پوشش واقعی بسیار بیشتر از این است.

آیا پوشش ۱۰۰٪ است؟
نه.
۱۰۰٪ یک مجانب است.

اما بعضی کدها سخت تست می‌شوند، نه؟
بله — اما فقط چون بد طراحی شده‌اند.
راه‌حلش این است که کدت را طوری طراحی کنی که تست‌پذیر باشد.
و بهترین راهش این است که اول تست را بنویسی، قبل از اینکه کدی بنویسی که تست را پاس کند.

این `discipline` (انضباط) به نام `Test Driven Development (TDD` / توسعهٔ مبتنی بر تست) شناخته می‌شود که بعداً بیشتر درباره‌اش صحبت می‌کنیم.

## QA خودکار

کل فرآیند QA در FitNesse اجرای `unit test` و `acceptance test` (تست پذیرش) است.
اگر این تست‌ها پاس شوند، من منتشر می‌کنم.
یعنی فرآیند QA من حدود سه دقیقه طول می‌کشد و هر وقت بخواهم می‌توانم آن را اجرا کنم.

درست است که اگر FitNesse باگ داشته باشد کسی نمی‌میرد.
کسی هم میلیون‌ها دلار از دست نمی‌دهد.
اما FitNesse هزاران کاربر دارد و لیست باگ‌هایش بسیار کوچک است.

بعضی سیستم‌ها آن‌قدر حیاتی هستند که یک تست خودکار کوتاه برای انتشار کافی نیست.
اما حداقل، تو به‌عنوان توسعه‌دهنده باید یک مکانیزم سریع و قابل‌اعتماد داشته باشی که بدانی کدی که نوشته‌ای کار می‌کند و به بقیهٔ سیستم آسیب نمی‌زند.
پس حداقل، تست‌های خودکارت باید به تو بگویند که سیستم با احتمال بسیار بالا QA را پاس می‌کند.

## آسیب نرساندن به `structure` (ساختار)

یک حرفه‌ای واقعی می‌داند که تحویل دادن `function` (عملکرد) به قیمت قربانی کردن `structure` (ساختار)، کاری احمقانه است.
این ساختار کد است که به آن انعطاف‌پذیری می‌دهد.
اگر ساختار را تخریب کنی، آینده را تخریب کرده‌ای.

فرض بنیادین همهٔ پروژه‌های نرم‌افزاری این است که نرم‌افزار تغییرپذیر است.
اگر با ایجاد ساختارهای خشک و غیرمنعطف این فرض را نقض کنی، در واقع مدل اقتصادی‌ای را که کل این صنعت بر آن بنا شده، تضعیف کرده‌ای.

به‌طور خلاصه:
باید بتوانی تغییر ایجاد کنی بدون هزینه‌های گزاف.

متأسفانه پروژه‌های زیادی در باتلاق ساختار ضعیف گیر می‌کنند.
کارهایی که قبلاً چند روز طول می‌کشیدند، شروع می‌کنند به چند هفته و بعد چند ماه زمان بردن.
مدیریت که از دست رفتن شتاب پروژه ناامید شده، توسعه‌دهندگان بیشتری استخدام می‌کند تا سرعت را بالا ببرد.
اما این توسعه‌دهندگان فقط به این باتلاق اضافه می‌شوند، آسیب ساختاری را عمیق‌تر می‌کنند و مانع‌ها را بیشتر.

دربارهٔ اصول و الگوهای طراحی نرم‌افزار که از ساختارهای انعطاف‌پذیر و قابل نگه‌داری پشتیبانی می‌کنند، بسیار نوشته شده است.
توسعه‌دهندگان حرفه‌ای این مفاهیم را به خاطر می‌سپارند و تلاش می‌کنند نرم‌افزارشان را با آن‌ها منطبق کنند.
اما یک ترفند وجود دارد که خیلی‌ها رعایتش نمی‌کنند:
اگر می‌خواهی نرم‌افزارت انعطاف‌پذیر باشد، باید آن را خم کنی!

تنها راه اثبات اینکه نرم‌افزارت به‌راحتی تغییر می‌کند این است که واقعاً تغییرات ساده روی آن اعمال کنی.
و وقتی دیدی تغییرها آن‌قدرها هم ساده نیستند، طراحی را اصلاح می‌کنی تا تغییر بعدی راحت‌تر شود.

چه زمانی این تغییرات ساده را انجام می‌دهی؟
همیشه.
هر بار که به یک ماژول نگاه می‌کنی، تغییرات کوچک و سبک برای بهبود ساختارش اعمال می‌کنی.
هر بار که کد را می‌خوانی، ساختارش را کمی تنظیم می‌کنی.

به این فلسفه گاهی `merciless refactoring` (بازآرایی بی‌رحمانه) می‌گویند.
من اسمش را گذاشته‌ام `Boy Scout rule` (قانون پیشاهنگ‌ها):
همیشه ماژولی را تحویل بده که تمیزتر از زمانی باشد که تحویل گرفتی.
هر بار که کدی را می‌بینی، یک عمل خیرخواهانهٔ تصادفی برایش انجام بده.

این طرز فکر کاملاً خلاف دیدگاه رایج دربارهٔ نرم‌افزار است.
بیشتر مردم فکر می‌کنند ایجاد تغییرات مداوم در نرم‌افزاری که کار می‌کند خطرناک است.
نه!
خطرناک این است که اجازه بدهی نرم‌افزار ثابت بماند.
اگر آن را خم نکنی، وقتی واقعاً مجبور به تغییرش شوی، متوجه می‌شوی که کاملاً خشک شده است.

چرا بیشتر توسعه‌دهندگان از ایجاد تغییرات مداوم می‌ترسند؟
چون می‌ترسند کد را خراب کنند.
چرا می‌ترسند خرابش کنند؟
چون تست ندارند.

باز هم همه‌چیز برمی‌گردد به تست.
اگر یک مجموعهٔ تست خودکار داشته باشی که تقریباً ۱۰۰٪ کد را پوشش دهد، و اگر این تست‌ها را بتوانی سریع و در لحظه اجرا کنی، دیگر از تغییر دادن کد نمی‌ترسی.
چطور ثابت می‌کنی که از تغییر دادن کد نمی‌ترسی؟
همیشه آن را تغییر می‌دهی.

توسعه‌دهندگان حرفه‌ای آن‌قدر به کد و تست‌هایشان مطمئن هستند که به‌طرز دیوانه‌کننده‌ای راحت تغییرات تصادفی و فرصت‌طلبانه ایجاد می‌کنند.
ممکن است دلبخواهی اسم یک کلاس را عوض کنند.
ممکن است وسط خواندن یک ماژول متوجه یک متد طولانی شوند و بدون معطلی آن را بازتقسیم کنند.
ممکن است یک switch statement را به polymorphic dispatch (ارسال چندریختی) تبدیل کنند، یا یک سلسله‌مراتب وراثتی را به chain-of-command تبدیل کنند.
به‌طور خلاصه، آن‌ها با نرم‌افزار مثل مجسمه‌ساز با گل رفتار می‌کنند — مدام شکلش می‌دهند و قالبش می‌زنند.

## اخلاق کاری (`Work Ethic`)

مسئولیت شغلی تو با خودت است.
این وظیفهٔ کارفرما نیست که مطمئن شود تو در بازار کار ارزشمند هستی.
این وظیفهٔ کارفرما نیست که تو را آموزش بدهد، یا به کنفرانس بفرستد، یا برایت کتاب بخرد.
این‌ها مسئولیت خودت هستند.
وای به حال توسعه‌دهنده‌ای که آیندهٔ شغلی‌اش را به کارفرمایش بسپارد.

بعضی کارفرماها حاضرند برایت کتاب بخرند یا تو را به دوره و کنفرانس بفرستند.
خوب است؛ دارند به تو لطف می‌کنند.
اما هرگز به این دام نیفت که فکر کنی این وظیفهٔ آن‌هاست.
اگر کارفرما این کارها را برایت انجام نداد، خودت باید راهی برای انجامشان پیدا کنی.

همچنین این وظیفهٔ کارفرما نیست که به تو زمان یادگیری بدهد.
بعضی کارفرماها این زمان را فراهم می‌کنند.
بعضی حتی اصرار می‌کنند که یاد بگیری.
اما باز هم این لطف است، نه تعهد.

تو به کارفرما مقدار مشخصی زمان و تلاش بدهکار هستی.
فرض کنیم استاندارد ۴۰ ساعت در هفته.
این ۴۰ ساعت باید صرف مشکلات کارفرما شود، نه مشکلات شخصی تو.

باید برنامه‌ریزی کنی که ۶۰ ساعت در هفته کار کنی.
۴۰ ساعت برای کارفرما.
۲۰ ساعت باقی‌مانده برای خودت.

در این ۲۰ ساعت باید مطالعه کنی، تمرین کنی، یاد بگیری و به‌طور کلی روی رشد حرفه‌ای‌ات سرمایه‌گذاری کنی.

می‌دانم چه فکری می‌کنی:
«خانواده‌ام چی؟ زندگیم چی؟ باید همه‌چیز را فدای کار کنم؟»

من دربارهٔ تمام وقت آزاد حرف نمی‌زنم.
دارم دربارهٔ ۲۰ ساعت اضافه در هفته حرف می‌زنم.
یعنی حدود روزی سه ساعت.
اگر ناهار را به مطالعه اختصاص بدهی، در مسیر رفت‌وآمد پادکست گوش بدهی، و روزی ۹۰ دقیقه یادگیری داشته باشی، این ۲۰ ساعت کاملاً پر می‌شود.

حسابش را بکن.
در هفته ۱۶۸ ساعت داریم.
۴۰ ساعت برای کارفرما، ۲۰ ساعت برای حرفه‌ات.
می‌شود ۶۰ ساعت.
۵۶ ساعت خواب کم کن، می‌ماند ۵۲ ساعت برای بقیهٔ زندگی.

شاید نخواهی چنین تعهدی بدهی.
اشکالی ندارد.
اما در آن صورت نباید خودت را حرفه‌ای بدانی.
حرفه‌ای‌ها برای حرفه‌شان وقت می‌گذارند.

آیا می‌دانی `Nassi-Schneiderman chart` (نمودار ناسی–شنایدرمن) چیست؟
اگر نه، چرا؟
آیا تفاوت بین `Mealy state machine` (ماشین حالت میلی) و `Moore state machine` (ماشین حالت مور) را می‌دانی؟
باید بدانی.

می‌توانی بدون نگاه کردن، الگوریتم `quicksort` (مرتب‌سازی سریع) را بنویسی؟
می‌دانی اصطلاح `Transform Analysis` (تحلیل تبدیل) به چه معناست؟
می‌توانی `functional decomposition` (تجزیهٔ کارکردی) را با استفاده از `Data Flow Diagrams` (`DFD` – نمودار جریان داده) انجام بدهی؟
اصطلاح `Tramp Data` (دادهٔ سرگردان) یعنی چه؟
تا به حال واژهٔ `Conascence` (هم‌وابستگی) را شنیده‌ای؟
`Parnas Table` (جدول پارناس) چیست؟

انبوهی از ایده‌ها، دیسیپلین‌ها، تکنیک‌ها، ابزارها و اصطلاحات، پنجاه سال گذشتهٔ حوزهٔ ما را شکل داده‌اند.
چقدر از این‌ها را می‌دانی؟
اگر می‌خواهی حرفه‌ای باشی، باید بخش قابل‌توجهی از آن‌ها را بدانی و مدام این بخش را بزرگ‌تر کنی.

چرا باید این چیزها را بدانی؟
مگر نه اینکه حوزهٔ ما آن‌قدر سریع پیش می‌رود که همهٔ این ایده‌های قدیمی دیگر بی‌ربط شده‌اند؟

بخش اول این سؤال در نگاه اول درست به نظر می‌رسد.
قطعاً حوزهٔ ما با سرعتی وحشیانه در حال پیشرفت است.
اما جالب اینجاست که این پیشرفت در بسیاری موارد حاشیه‌ای است.

درست است که دیگر ۲۴ ساعت منتظر کامپایل نمی‌مانیم.
درست است که سیستم‌هایی با اندازهٔ چند گیگابایت می‌نویسیم.
درست است که در دل یک شبکهٔ جهانی کار می‌کنیم که دسترسی آنی به اطلاعات می‌دهد.
اما از طرف دیگر، هنوز همان if و while‌هایی را می‌نویسیم که ۵۰ سال پیش نوشته می‌شد.

خیلی چیزها تغییر کرده‌اند.
خیلی چیزها هم تغییر نکرده‌اند.

بخش دوم سؤال قطعاً نادرست است.
بسیار کم‌اند ایده‌هایی از ۵۰ سال گذشته که واقعاً بی‌ربط شده باشند.
برخی کنار گذاشته شده‌اند، درست است.
مثلاً توسعهٔ waterfall (آبشاری) دیگر محبوب نیست.
اما این به این معنا نیست که نباید بدانیم چیست و نقاط قوت و ضعفش کدام‌اند.

در مجموع، بیشتر ایده‌هایی که با زحمت فراوان طی این ۵۰ سال به دست آمده‌اند، امروز هم به همان اندازهٔ گذشته ارزشمندند — شاید حتی ارزشمندتر.

یادآور نفرین Santayana (سانتایانا):
«کسانی که گذشته را به یاد نمی‌آورند، محکوم‌اند که آن را تکرار کنند.»

### در اینجا یک فهرست حداقلی از چیزهایی است که هر توسعه‌دهندهٔ نرم‌افزار حرفه‌ای باید با آن‌ها آشنا باشد:

- `Design Patterns` (الگوهای طراحی)
باید بتوانی هر ۲۴ الگوی کتاب GOF (Gang of Four) را توضیح بدهی و شناخت عملی از بسیاری از الگوهای کتاب‌های POSA (Pattern-Oriented Software Architecture) داشته باشی.

- `Design Principles` (اصول طراحی)
باید اصول SOLID را بدانی و درک خوبی از اصول کامپوننت‌ها داشته باشی.

- `Methods` (روش‌ها)
باید XP، Scrum، Lean، Kanban، Waterfall، Structured Analysis، Structured Design را بفهمی.

- `Disciplines` (دیسیپلین‌ها)
باید TDD (Test Driven Development)، طراحی شیءگرا، Structured Programming (برنامه‌نویسی ساخت‌یافته)، Continuous Integration (یکپارچه‌سازی مداوم) و Pair Programming (برنامه‌نویسی دونفره) را تمرین کنی.

- `Artifacts` (مصنوعات/خروجی‌ها)
باید بلد باشی از UML، DFDs، Structure Charts، Petri Nets، State Transition Diagrams and Tables، flow charts، decision tables استفاده کنی.

## یادگیری مداوم (`Continuous Learning`)

سرعت سرسام‌آور تغییر در صنعت ما یعنی توسعه‌دهندگان نرم‌افزار مجبورند دائماً حجم عظیمی از مطالب را یاد بگیرند، فقط برای اینکه عقب نمانند.

وای به حال معمارانی که کدنویسی را کنار می‌گذارند — خیلی زود بی‌ربط می‌شوند.
وای به حال برنامه‌نویسانی که یادگیری زبان‌های جدید را متوقف می‌کنند — می‌بینند صنعت از کنارشان عبور می‌کند.
وای به حال توسعه‌دهندگانی که دیسیپلین‌ها و تکنیک‌های جدید را یاد نمی‌گیرند — همتایانشان رشد می‌کنند و آن‌ها افول.

آیا به پزشکی مراجعه می‌کنی که مقالات پزشکی جدید را دنبال نمی‌کند؟
آیا وکیل مالیاتی‌ای استخدام می‌کنی که قوانین و رویه‌های جدید را نمی‌داند؟
پس چرا کارفرما باید توسعه‌دهنده‌ای را استخدام کند که به‌روز نیست؟

کتاب بخوان.
مقاله بخوان.
وبلاگ‌ها و توییت‌ها را دنبال کن.
به کنفرانس‌ها برو.
در گروه‌های کاربری شرکت کن.
در گروه‌های مطالعه و خواندن مشارکت کن.
چیزهایی را یاد بگیر که خارج از منطقهٔ امن تو هستند.

اگر برنامه‌نویس .NET هستی، Java یاد بگیر.
اگر Java کار می‌کنی، Ruby یاد بگیر.
اگر C کار می‌کنی، Lisp یاد بگیر.
و اگر واقعاً می‌خواهی ذهنت را خم کنی، Prolog و Forth یاد بگیر.

## تمرین (`Practice`)

حرفه‌ای‌ها تمرین می‌کنند.
حرفه‌ای‌های واقعی سخت تلاش می‌کنند تا مهارت‌هایشان تیز و آماده بماند.

این کافی نیست که فقط کار روزانه‌ات را انجام بدهی و اسمش را تمرین بگذاری.
کار روزانه اجرا (performance) است، نه تمرین.
تمرین یعنی عمداً مهارت‌هایت را بیرون از کار روزانه، فقط برای بهتر شدن، تقویت کنی.

تمرین برای یک توسعه‌دهندهٔ نرم‌افزار یعنی چه؟
در نگاه اول شاید مسخره به نظر برسد.
اما کمی فکر کن.

موسیقی‌دان‌ها چطور استاد کارشان می‌شوند؟
نه با اجرا، بلکه با تمرین.
آن‌ها تمرین‌های خاص دارند: scales، etudes، runs.
این‌ها را بارها و بارها تکرار می‌کنند تا انگشتان و ذهنشان را تربیت کنند.

پس توسعه‌دهنده‌ها چه کار می‌کنند؟
در این کتاب یک فصل کامل به تکنیک‌های تمرین اختصاص دارد، پس اینجا وارد جزئیات نمی‌شوم.
یکی از تکنیک‌هایی که من زیاد استفاده می‌کنم، تکرار تمرین‌های ساده مثل Bowling Game یا Prime Factors است.
من به این تمرین‌ها kata می‌گویم.

یک kata معمولاً یک مسئلهٔ سادهٔ برنامه‌نویسی است، مثلاً نوشتن تابعی که فاکتورهای اول یک عدد را حساب کند.
هدف kata حل مسئله نیست — تو قبلاً بلدش هستی.
هدف، تمرین دادن انگشتان و مغز است.

من هر روز یک یا دو kata انجام می‌دهم، اغلب برای گرم کردن قبل از شروع کار.
ممکن است با Java، Ruby، Clojure یا هر زبانی که می‌خواهم مهارتم را در آن حفظ کنم انجامش بدهم.
از kata برای تیز کردن مهارت‌های خاص استفاده می‌کنم، مثل استفاده از میان‌برهای صفحه‌کلید یا refactoringهای مشخص.

kata را مثل یک تمرین گرم‌کردن ۱۰ دقیقه‌ای صبح و یک سرد کردن ۱۰ دقیقه‌ای عصر در نظر بگیر.

## همکاری (`Collaboration`)

دومین راه بهتر یادگیری، همکاری با دیگران است.
توسعه‌دهندگان حرفه‌ای عمداً کنار هم برنامه‌نویسی می‌کنند، تمرین می‌کنند، طراحی و برنامه‌ریزی می‌کنند.
با این کار هم از هم یاد می‌گیرند و هم سریع‌تر و با خطای کمتر کار را جلو می‌برند.

این به این معنا نیست که باید ۱۰۰٪ زمانت را با دیگران بگذرانی.
زمان تنهایی هم بسیار مهم است.
هرچقدر هم pair programming را دوست داشته باشم، اگر گاهی نتوانم تنها باشم، دیوانه می‌شوم.

### منتورینگ (`Mentoring`)

بهترین راه یادگیری، آموزش دادن است.
هیچ‌چیز سریع‌تر و عمیق‌تر از آموزش دادن، مفاهیم و ارزش‌ها را در ذهنت تثبیت نمی‌کند.

به همین دلیل، سود آموزش بیشتر به نفع معلم است.
به همان اندازه، بهترین راه وارد کردن افراد جدید به سازمان این است که کنارشان بنشینی و راه را نشانشان بدهی.
حرفه‌ای‌ها مسئولیت شخصی منتور کردن juniorها را می‌پذیرند.
آن‌ها اجازه نمی‌دهند یک junior بدون نظارت دست‌وپا بزند.

### شناخت دامنه (`Know Your Domain`)

مسئولیت هر توسعه‌دهندهٔ حرفه‌ای است که دامنهٔ مسئله‌ای را که روی آن کدنویسی می‌کند بفهمد.
اگر سیستم حسابداری می‌نویسی، باید حسابداری بدانی.
اگر نرم‌افزار گردشگری می‌نویسی، باید صنعت گردشگری را بشناسی.

لازم نیست متخصص دامنه باشی، اما باید مقدار معقولی due diligence (دقت لازم) انجام بدهی.

وقتی وارد دامنهٔ جدیدی می‌شوی، یکی دو کتاب درباره‌اش بخوان.
با مشتری و کاربران دربارهٔ مبانی دامنه مصاحبه کن.
مدتی با متخصص‌ها وقت بگذران و سعی کن اصول و ارزش‌هایشان را بفهمی.

بدترین نوع رفتار غیرحرفه‌ای این است که بدون فهمیدن دلیل منطقی یک spec (مشخصات) فقط بر اساس آن کدنویسی کنی.
باید آن‌قدر دامنه را بفهمی که بتوانی خطاهای specification را تشخیص بدهی و به چالش بکشی.

### همذات‌پنداری با کارفرما / مشتری (`Identify with Your Employer / Customer`)

مشکلات کارفرما، مشکلات تو هستند.
باید بفهمی این مشکلات چیست و برای بهترین راه‌حل‌ها تلاش کنی.

وقتی سیستم توسعه می‌دهی، باید خودت را جای کارفرما بگذاری و مطمئن شوی ویژگی‌هایی که می‌سازی واقعاً نیازهای او را برطرف می‌کنند.

خیلی راحت است که توسعه‌دهندگان فقط با هم‌صنفی‌هایشان همذات‌پنداری کنند و در دام «ما در برابر آن‌ها» نسبت به کارفرما بیفتند.
حرفه‌ای‌ها به هر قیمتی از این دام دوری می‌کنند.

### فروتنی (`Humility`)

برنامه‌نویسی یک عمل آفرینش است.
ما از هیچ، چیزی خلق می‌کنیم.
با جسارت، نظم را بر هرج‌ومرج تحمیل می‌کنیم.
با اعتمادبه‌نفس، رفتارهای ماشینی را کنترل می‌کنیم که در غیر این صورت می‌تواند خسارات غیرقابل محاسبه‌ای ایجاد کند.
پس برنامه‌نویسی عملی به‌شدت متکبرانه است.

حرفه‌ای‌ها می‌دانند متکبرند و تظاهر به فروتنی نمی‌کنند.
حرفه‌ای کارش را بلد است و به کارش افتخار می‌کند.
به توانایی‌هایش اعتماد دارد و بر اساس آن ریسک‌های حساب‌شده می‌کند.
حرفه‌ای ترسو نیست.

اما حرفه‌ای می‌داند که گاهی شکست می‌خورد، محاسباتش غلط از آب درمی‌آید و توانایی‌هایش کافی نیست.
گاهی در آینه نگاه می‌کند و یک احمق متکبر می‌بیند که به او لبخند می‌زند.

برای همین، وقتی حرفه‌ای سوژهٔ شوخی می‌شود، اولین کسی است که می‌خندد.
هرگز دیگران را مسخره نمی‌کند، اما اگر مسخره شد، اگر حقش باشد می‌پذیرد و اگر نباشد، بی‌خیال می‌خندد.
او کسی را به خاطر اشتباه تحقیر نمی‌کند، چون می‌داند ممکن است نفر بعدی خودش باشد.

حرفه‌ای از تکبر ذاتی خودش آگاه است و می‌داند سرنوشت بالاخره نشانه می‌گیرد.
وقتی تیر به هدف خورد، بهترین کاری که می‌توانی بکنی همان است که Howard گفته:
بخند.


</div>


* [فصل قبل](../00_Pre_Requisite_Introduction/Pre_Requisite_Introduction.md)
